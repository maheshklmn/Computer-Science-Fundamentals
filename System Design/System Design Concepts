/*
What is System Design?
System Design is the process of defining the architecture, components, modules, interfaces, and data for a system to satisfy specified requirements. It's about making strategic decisions that affect the entire system.

In simple terms: System Design is like creating a blueprint for building scalable, reliable, and efficient software systems.

Core System Design Concepts
1. Scalability
The ability of a system to handle increased load by adding resources.

Types of Scaling:

Vertical Scaling (Scale Up): Add more power to existing machines (CPU, RAM)

Horizontal Scaling (Scale Out): Add more machines to distribute load

Example: A web application that can handle 100 users should also handle 1 million users.

2. Reliability
The system should work correctly and consistently, even when components fail.

Strategies:

Redundancy: Multiple copies of critical components

Failover: Automatic switching to backup systems

Monitoring: Continuous health checks

3. Availability
The percentage of time the system is operational and accessible.

Measured as:

99.9% availability = 8.76 hours downtime per year

99.99% availability = 52.6 minutes downtime per year

99.999% availability = 5.26 minutes downtime per year

4. Maintainability
How easily the system can be modified, updated, and fixed.

Principles:

Modularity: Break system into independent components

Clean Code: Readable and well-documented

Testing: Comprehensive test coverage

5. Performance
How efficiently the system uses resources and responds to requests.

Metrics:

Latency: Time to complete a single operation

Throughput: Number of operations per second

Response Time: Time between request and response

Key Architectural Patterns
1. Monolithic Architecture
Single codebase containing all functionality

Simple to develop and deploy

Becomes complex as system grows

Single point of failure

2. Microservices Architecture
Multiple small, independent services

Each service has specific business capability

Communicate via APIs (REST, gRPC)

Better scalability and fault isolation

3. Client-Server Architecture
Clients request services

Servers provide services

Clear separation of concerns

Centralized management

4. Event-Driven Architecture
Components communicate through events

Loose coupling between services

Highly scalable and responsive

Complex to debug

Essential Components in System Design
1. Load Balancer
Distributes incoming traffic across multiple servers to prevent overload.

Types:

Round Robin: Distribute requests sequentially

Least Connections: Send to server with fewest active connections

IP Hash: Consistent routing based on client IP

2. Database
SQL Databases: Structured data with relationships (MySQL, PostgreSQL)
NoSQL Databases: Flexible schema for unstructured data (MongoDB, Cassandra)
Caching: Fast in-memory storage (Redis, Memcached)

3. Message Queue
Asynchronous communication between services.

Examples: RabbitMQ, Kafka, SQS
Use Cases: Order processing, notification systems

4. CDN (Content Delivery Network)
Distributed servers to deliver content efficiently.

Benefits: Reduced latency, lower server load
Examples: CloudFront, Akamai, Cloudflare

Design Principles
1. SOLID Principles
Single Responsibility: One class, one purpose

Open/Closed: Open for extension, closed for modification

Liskov Substitution: Subtypes should be substitutable

Interface Segregation: Many specific interfaces

Dependency Inversion: Depend on abstractions, not concretions

2. CAP Theorem
In distributed systems, you can only have two of three:

Consistency: All nodes see same data at same time

Availability: Every request gets a response

Partition Tolerance: System works despite network failures

3. ACID vs BASE
ACID: Consistency-focused (SQL databases)

BASE: Availability-focused (NoSQL databases)

Java System Design Example
Microservice Architecture Example:
User Service:

java
// User Service - handles user management
@RestController
public class UserController {
    @Autowired
    private UserService userService;
    
    @PostMapping("/users")
    public User createUser(@RequestBody User user) {
        return userService.createUser(user);
    }
    
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable String id) {
        return userService.getUser(id);
    }
}

@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(User user) {
        // Business logic and validation
        return userRepository.save(user);
    }
}
Order Service:

java
// Order Service - handles order processing
@RestController
public class OrderController {
    @Autowired
    private OrderService orderService;
    
    @PostMapping("/orders")
    public Order createOrder(@RequestBody Order order) {
        return orderService.createOrder(order);
    }
}

@Service
public class OrderService {
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private RestTemplate restTemplate;
    
    public Order createOrder(Order order) {
        // Call User Service to validate user
        User user = restTemplate.getForObject(
            "http://user-service/users/" + order.getUserId(), User.class);
        
        if (user != null) {
            return orderRepository.save(order);
        }
        throw new RuntimeException("User not found");
    }
}
Database Design Example:
java
// Using JPA for database interactions
@Entity
public class User {
    @Id
    private String id;
    private String name;
    private String email;
    
    @OneToMany(mappedBy = "user")
    private List<Order> orders;
}

@Entity
public class Order {
    @Id
    private String id;
    private BigDecimal amount;
    
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}
Caching Implementation:
java
@Service
public class ProductService {
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private RedisTemplate<String, Product> redisTemplate;
    
    public Product getProduct(String id) {
        // Check cache first
        Product product = redisTemplate.opsForValue().get("product:" + id);
        if (product == null) {
            // Cache miss - get from database
            product = productRepository.findById(id).orElse(null);
            if (product != null) {
                // Store in cache for 1 hour
                redisTemplate.opsForValue().set(
                    "product:" + id, product, Duration.ofHours(1));
            }
        }
        return product;
    }
}
System Design Interview Approach
Step-by-Step Process:
Clarify Requirements

Ask about scale, features, constraints

Define use cases and user stories

Estimate Scale

Number of users, requests per second

Storage requirements, bandwidth needs

High-Level Design

Draw architecture diagram

Identify main components and their interactions

Deep Dive

Database schema design

API design

Scaling strategies

Identify Bottlenecks

Single points of failure

Performance issues

Security concerns

Common Interview Questions:
"Design Twitter"

"Design Uber"

"Design Netflix"

"Design URL Shortener"

"Design Chat System"

*/
